# Implementation file of the Saleae Device library.  This file contains# a Python-accessible Device Manager that listens for device connections,# disconnections, errors, and data reads.  When a device connects (is plugged# into a USB port) it is automatically wired up to the OnReadData and OnError# callbacks defined at the bottom of this file.# Cython importscimport SaleaeDevicecimport numpy as npfrom analyzer cimport Analyzer# Python importsimport numpy as npfrom libc.string cimport memcpyimport cythonimport timecdef extern from "Python.h":     void PyEval_InitThreads()# Valid sampling rates (from the Saleae source code)VALID_SAMPLING_RATES = [500000, 1000000, 2000000, 4000000, 5000000, 8000000, 10000000,                        12500000, 16000000, 25000000, 32000000, 40000000, 50000000,                        80000000, 100000000]# Some defines for various types of eventsEVENT_ID_ALL_EVENTS     = -1EVENT_ID_ONCONNECT      = 0EVENT_ID_ONDISCONNECT   = 1EVENT_ID_ONERROR        = 3EVENT_ID_ONREADDATA     = 4EVENT_ID_ONANALYZERDATA = 5# ----------------------------------------------------------------------------class SaleaeEvent(object):    """A simple class for an event."""    def __init__(self, _id, _name, _data=None):        self.id = _id        self.name = _name        self.data = _data# ----------------------------------------------------------------------------_EVENT_LIST = (                 SaleaeEvent(EVENT_ID_ONCONNECT, 'OnConnect'),                SaleaeEvent(EVENT_ID_ONDISCONNECT, 'OnDisconnect'),                SaleaeEvent(EVENT_ID_ONERROR, 'OnError'),                SaleaeEvent(EVENT_ID_ONREADDATA, 'OnReadData'),                SaleaeEvent(EVENT_ID_ONANALYZERDATA, 'OnAnalyzerData'),              )EVENT_DICT = dict(zip([w.id for w in _EVENT_LIST], _EVENT_LIST))# ----------------------------------------------------------------------------class PyDevicesManager(object):    """A class managing the current connected Logic devices."""    CONNECTED_DEVICES = {}    LISTENERS = dict(zip([w.id for w in _EVENT_LIST], [list() for x in _EVENT_LIST]))    @staticmethod    def add_device(pylogicdevice):        """Called automatically by the underlying framework when a device           is connected. Shouldn't be called by the user."""        PyDevicesManager.CONNECTED_DEVICES[pylogicdevice.get_id()] = pylogicdevice        PyDevicesManager.notify(EVENT_DICT[EVENT_ID_ONCONNECT], pylogicdevice.get_id())    @staticmethod    def on_disconnect(id):        """Called automatically by the underlying framework when a device           disconnects. Shouldn't be called by the user."""        try:            PyDevicesManager.notify(EVENT_DICT[EVENT_ID_ONDISCONNECT], id)        except KeyError:            pass        PyDevicesManager.remove_device(id)    @staticmethod    def on_error(id, message="Unknown error"):        """Called automatically by the underlying framework when an error           occurs. Shouldn't be called by the user."""        try:            event = SaleaeEvent(EVENT_ID_ONERROR, 'OnError', message)            PyDevicesManager.notify(event, id)        except KeyError:            pass    @staticmethod    def on_analyzer_data(id, np.ndarray data):        """Called when a block of data has been analyzed. Intended to be called            by the analyzer."""        try:            event = SaleaeEvent(EVENT_ID_ONANALYZERDATA, 'OnAnalyzerData', data)            PyDevicesManager.notify(event, id)        except KeyError:            pass    @staticmethod    def on_read_data16(id, np.ndarray[np.npy_uint16] data):        """Called automatically by the underlying framework when a block of           16-bit data arrives (from a Logic16). Shouldn't be called by the user."""        try:            event = SaleaeEvent(EVENT_ID_ONREADDATA, 'OnReadData', data)            PyDevicesManager.notify(event, id)        except KeyError:            pass    def on_read_data8(id, np.ndarray[np.npy_uint8] data):        """Called automatically by the underlying framework when a block of           8-bit data arrives (from a Logic). Shouldn't be called by the user."""        try:            event = SaleaeEvent(EVENT_ID_ONREADDATA, 'OnReadData', data)            PyDevicesManager.notify(event, id)        except KeyError:            pass    @staticmethod    def remove_device(id):        """Called automatically by the underlying framework when a device has           disconnected. Shouldn't be called by the user."""        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            if device is not None and device.is_streaming():                device.stop()            if device.analyzer is not None:                device.analyzer.set_interface(None)            del PyDevicesManager.CONNECTED_DEVICES[id]        except KeyError:            pass    @staticmethod    def get_device(id):        """Get the connected Logic or Logic16 device for the given ID."""        try:            return PyDevicesManager.CONNECTED_DEVICES[id]        except KeyError:            pass        return None    @staticmethod    def get_devices():        """Gets a dictionary of all connected devices."""        return PyDevicesManager.CONNECTED_DEVICES    @staticmethod    def begin_connect():        """Start monitoring events. Intended to be called by the user."""        BeginConnect()    @staticmethod    def register_listener(listener, event_id):        """Register a listener on a given event. Intended to be called by the user."""        if hasattr(listener, "on_event") or callable(listener):            if event_id == EVENT_ID_ALL_EVENTS:                for _id, _list in PyDevicesManager.LISTENERS.iteritems():                    if listener not in _list:                        _list.append(listener)                        PyDevicesManager.LISTENERS[_id] = _list            else:                current_list = PyDevicesManager.LISTENERS[event_id]                if listener not in current_list:                    current_list.append(listener)                    PyDevicesManager.LISTENERS[event_id] = current_list    @staticmethod    def notify(event, device_id):        """Internal method to notify the current event listeners. Not intended           to be called by the user."""        _list = PyDevicesManager.LISTENERS[event.id]        for listener in _list:            if hasattr(listener, "on_event"):                listener.on_event(event, device_id)            else:                listener(event, device_id)# ----------------------------------------------------------------------------# Internal classes.# ----------------------------------------------------------------------------cdef class PyGenericInterface:    cdef public Analyzer analyzer    cdef public U64 id    def __init__(self, id):        # calling "__new__()" will not call "__init__()" !        raise TypeError("This class cannot be instantiated from Python")    def __cinit__(self, U64 id):        self.id = id    def get_id(self,):        return self.id    def set_analyzer(self, analyzer):        self.analyzer = analyzer        analyzer.set_interface(self)    def get_analyzer(self,):        return self.analyzer# ----------------------------------------------------------------------------cdef class PyLogicInterface(PyGenericInterface):    # The underlying Logic device we are wrapping    cdef LogicInterface *thisptr    def read_start(self,):        self.thisptr.ReadStart()    def stop(self,):        if self.thisptr != NULL:            self.thisptr.Stop()        if self.analyzer is not None:            self.analyzer.stop()    def is_streaming(self,):        return self.thisptr.IsStreaming()    def set_sampling_rate_hz(self, sampling_rate):        self.thisptr.SetSampleRateHz( sampling_rate )    def get_sampling_rate_hz(self,):        return self.thisptr.GetSampleRateHz( )# ----------------------------------------------------------------------------cdef class PyLogic16Interface(PyGenericInterface):    # The underlying Logic16 device we are wrapping    cdef Logic16Interface *thisptr    def read_start(self,):        self.thisptr.ReadStart()    def stop(self,):        if self.thisptr != NULL:            self.thisptr.Stop()        if self.analyzer is not None:            self.analyzer.stop()    def is_streaming(self,):        return self.thisptr.IsStreaming()    def set_sampling_rate_hz(self, sampling_rate):        self.thisptr.SetSampleRateHz( sampling_rate )    def get_sampling_rate_hz(self,):        return self.thisptr.GetSampleRateHz( )    def set_use_5_volts(self, use_5_volts):        self.thisptr.SetUse5Volts( use_5_volts )    def set_active_channels(self, channel_list):        cdef U32 channels[16]     # Just create an array of max_channel size        cdef U32 num_channels = len(channel_list)        cdef unsigned int i        # Only populate the channels we want, zero out the rest        for i in range(16):            if i < num_channels:                channels[i] = channel_list[i]            else:                channels[i] = 0        self.thisptr.SetActiveChannels( channels, num_channels )# ----------------------------------------------------------------------------# Factory functions to create the Cython wrapper instances# ----------------------------------------------------------------------------cdef PyLogicInterface PyLogicInterface_factory(U64 _id, LogicInterface *cppLogicInterface):    cdef PyLogicInterface instance = PyLogicInterface.__new__(PyLogicInterface, _id)    instance.thisptr = cppLogicInterface    return instance# ----------------------------------------------------------------------------cdef PyLogic16Interface PyLogic16Interface_factory(U64 _id, Logic16Interface *cppLogic16Interface):    cdef PyLogic16Interface instance = PyLogic16Interface.__new__(PyLogic16Interface, _id)    instance.thisptr = cppLogic16Interface    return instance# ----------------------------------------------------------------------------# Callback for when a device is connected. Creates a Cython-wrapped instance# and adds it to the device manager, registering its OnReadData and OnError# to the internal callbacks below.# ----------------------------------------------------------------------------cdef void __stdcall OnConnect( U64 device_id, GenericInterface* device_interface, void* user_data ) with gil:    cdef Logic16Interface *logic16    cdef LogicInterface *logic    pylogic_interface = None    try:        logic16 = <Logic16Interface*?>device_interface        pylogic_interface = PyLogic16Interface_factory(device_id, logic16)    except TypeError:        logic = <LogicInterface*?>device_interface        pylogic_interface = PyLogicInterface_factory(device_id, logic)    if pylogic_interface is not None:        (<LogicInterface *> device_interface).RegisterOnReadData(&OnReadData)        (<LogicInterface *> device_interface).RegisterOnError(&OnError)        PyDevicesManager.add_device(pylogic_interface)# ----------------------------------------------------------------------------# The Saleae OnError callback - just calls the underlying equivalent# method on the device manager.# ----------------------------------------------------------------------------cdef void __stdcall OnError( U64 device_id, void* user_data ) with gil:    PyDevicesManager.on_error(device_id)# ----------------------------------------------------------------------------# The Saleae OnDisconnect callback - just calls the underlying equivalent# method on the device manager.# ----------------------------------------------------------------------------cdef void __stdcall OnDisconnect( U64 device_id, void* user_data ) with gil:    PyDevicesManager.on_disconnect(device_id)# ----------------------------------------------------------------------------# The Saleae OnReadData callback. Depending on whether or not the device is a# Logic or a Logic16, calls the device manager's appropriate OnReadData method.# If there is an analyzer attached to the device, add the data block to the# analyzer for analysis. This could be done from the device manager, but it# is pure Python, and is much faster if called here from Cython.# ----------------------------------------------------------------------------cdef void __stdcall OnReadData( U64 device_id, U8* data, U32 data_length, void* user_data ) with gil:    cdef PyLogic16Interface device = PyDevicesManager.get_device(device_id)    cdef U16* data16    cdef np.ndarray[np.npy_uint16] n16    cdef np.ndarray[np.npy_uint8] n8    cdef Analyzer analyzer    if device is not None:        analyzer = device.get_analyzer()        if analyzer is not None:            if isinstance(device, PyLogic16Interface):                n16 = np.zeros(data_length / 2, dtype=np.uint16)                data16 = <U16*> data                # memcpy takes number of 'bytes' to copy (which is why it is not data_length/2)                memcpy(n16.data, data16, data_length)                analyzer.add_u16_data_block(n16)                PyDevicesManager.on_read_data16(device_id, n16)            else:                n8 = np.zeros(data_length, dtype=np.uint8)                memcpy(n8.data, data, data_length)                analyzer.add_u8_data_block(n8)                PyDevicesManager.on_read_data8(device_id, n8)    DeleteU8ArrayPtr(data)        # ----------------------------------------------------------------------------# Initialize the Python thread state and register our OnConnect and OnDisconnect# callbacks.# ----------------------------------------------------------------------------PyEval_InitThreads()RegisterOnConnect(&OnConnect)RegisterOnDisconnect(&OnDisconnect)