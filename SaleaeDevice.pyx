# Implementation file of the Saleae Device library.  This file contains# a Python-accessible Device Manager that listens for device connections,# disconnections, errors, and data reads.  When a device connects (is plugged# into a USB port) it is automatically wired up to the OnReadData and OnError# callbacks defined at the bottom of this file.# Cython importscimport SaleaeDevicecimport numpy as npfrom analyzer cimport Analyzer# Python importsimport numpy as npfrom libc.string cimport memcpyimport cythoncdef extern from "Python.h":     void PyEval_InitThreads()VALID_SAMPLING_RATES = [500000, 1000000, 2000000, 4000000, 5000000, 8000000, 10000000,                        12500000, 16000000, 25000000, 32000000, 40000000, 50000000,                        80000000, 100000000]EVENT_ID_ALL_EVENTS     = -1EVENT_ID_ONCONNECT      = 0EVENT_ID_ONDISCONNECT   = 1EVENT_ID_ONERROR        = 3EVENT_ID_ONREADDATA     = 4EVENT_ID_ONANALYZERDATA = 5# ----------------------------------------------------------------------------class SaleaeEvent(object):    def __init__(self, _id, _name, _data=None):        self.id = _id        self.name = _name        self.data = _data# ----------------------------------------------------------------------------_EVENT_LIST = (                 SaleaeEvent(EVENT_ID_ONCONNECT, 'OnConnect'),                SaleaeEvent(EVENT_ID_ONDISCONNECT, 'OnDisconnect'),                SaleaeEvent(EVENT_ID_ONERROR, 'OnError'),                SaleaeEvent(EVENT_ID_ONREADDATA, 'OnReadData'),                SaleaeEvent(EVENT_ID_ONANALYZERDATA, 'OnAnalyzerData'),              )EVENT_DICT = dict(zip([w.id for w in _EVENT_LIST], _EVENT_LIST))# ----------------------------------------------------------------------------class PyDevicesManager(object):    CONNECTED_DEVICES = {}    LISTENERS = dict(zip([w.id for w in _EVENT_LIST], [list() for x in _EVENT_LIST]))    @staticmethod    def add_device(pylogicdevice):        PyDevicesManager.CONNECTED_DEVICES[pylogicdevice.get_id()] = pylogicdevice        PyDevicesManager.notify(EVENT_DICT[EVENT_ID_ONCONNECT], pylogicdevice)    @staticmethod    def on_disconnect(id):        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            PyDevicesManager.notify(EVENT_DICT[EVENT_ID_ONDISCONNECT], device)        except KeyError:            pass        PyDevicesManager.remove_device(id)    @staticmethod    def on_error(id, message="Unknown error"):        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            event = SaleaeEvent(EVENT_ID_ONERROR, 'OnError', message)            PyDevicesManager.notify(event, device)        except KeyError:            pass    @staticmethod    def on_analyzer_data(id, np.ndarray data):        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            event = SaleaeEvent(EVENT_ID_ONANALYZERDATA, 'OnAnalyzerData', data)            PyDevicesManager.notify(event, device)        except KeyError:            pass    @staticmethod    def on_read_data16(id, np.ndarray[np.npy_uint16] data):        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            event = SaleaeEvent(EVENT_ID_ONREADDATA, 'OnReadData', data)            PyDevicesManager.notify(event, device)        except KeyError:            pass    def on_read_data8(id, np.ndarray[np.npy_uint8] data):        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            event = SaleaeEvent(EVENT_ID_ONREADDATA, 'OnReadData', data)            PyDevicesManager.notify(event, device)        except KeyError:            pass    @staticmethod    def remove_device(id):        try:            device = PyDevicesManager.CONNECTED_DEVICES[id]            if device.is_streaming():                device.stop()            del PyDevicesManager.CONNECTED_DEVICES[id]        except KeyError:            pass    @staticmethod    def get_device(id):        try:            return PyDevicesManager.CONNECTED_DEVICES[id]        except KeyError:            pass        return None    @staticmethod    def get_devices():        return PyDevicesManager.CONNECTED_DEVICES    @staticmethod    def begin_connect():        BeginConnect()    @staticmethod    def register_listener(listener, event_id):        if hasattr(listener, "on_event") or callable(listener):            if event_id == EVENT_ID_ALL_EVENTS:                for _id, _list in PyDevicesManager.LISTENERS.iteritems():                    if listener not in _list:                        _list.append(listener)                        PyDevicesManager.LISTENERS[_id] = _list            else:                current_list = PyDevicesManager.LISTENERS[event_id]                if listener not in current_list:                    current_list.append(listener)                    PyDevicesManager.LISTENERS[event_id] = current_list    @staticmethod    def notify(event, pylogicdevice):        _list = PyDevicesManager.LISTENERS[event.id]        for listener in _list:            if hasattr(listener, "on_event"):                listener.on_event(event, pylogicdevice)            else:                listener(event, pylogicdevice)# ----------------------------------------------------------------------------cdef class PyGenericInterface:    cdef Analyzer analyzer    cdef U64 id    def __init__(self,):        # calling "__new__()" will not call "__init__()" !        raise TypeError("This class cannot be instantiated from Python")    def __cinit__(self, *args, **kwargs):        pass    def __dealloc__(self,):        pass    def get_id(self,):        return self.id    def set_analyzer(self, analyzer):        self.analyzer = analyzer        analyzer.set_interface(self)    def get_analyzer(self,):        return self.analyzer# ----------------------------------------------------------------------------cdef class PyLogicInterface(PyGenericInterface):    cdef LogicInterface *thisptr    def __dealloc__(self,):        if self.thisptr != NULL:            del self.thisptr    def read_start(self,):        self.thisptr.ReadStart()    def stop(self,):        if self.thisptr != NULL:            self.thisptr.Stop()        if self.analyzer is not None:            self.analyzer.stop()    def is_streaming(self,):        return self.thisptr.IsStreaming()    def set_sampling_rate_hz(self, sampling_rate):        self.thisptr.SetSampleRateHz( sampling_rate )    def get_sampling_rate_hz(self,):        return self.thisptr.GetSampleRateHz( )# ----------------------------------------------------------------------------cdef class PyLogic16Interface(PyGenericInterface):    cdef Logic16Interface *thisptr    def __dealloc__(self,):        if self.thisptr != NULL:            del self.thisptr    def read_start(self,):        self.thisptr.ReadStart()    def stop(self,):        if self.thisptr != NULL:            self.thisptr.Stop()        if self.analyzer is not None:            self.analyzer.stop()    def is_streaming(self,):        return self.thisptr.IsStreaming()    def set_sampling_rate_hz(self, sampling_rate):        self.thisptr.SetSampleRateHz( sampling_rate )    def get_sampling_rate_hz(self,):        return self.thisptr.GetSampleRateHz( )    def set_use_5_volts(self, use_5_volts):        self.thisptr.SetUse5Volts( use_5_volts )    def set_active_channels(self, channel_list):        cdef U32 channels[16]     # Just create an array of max_channel size        cdef U32 num_channels = len(channel_list)        cdef unsigned int i        # Only populate the channels we want, zero out the rest        for i in range(16):            if i < num_channels:                channels[i] = channel_list[i]            else:                channels[i] = 0        self.thisptr.SetActiveChannels( channels, num_channels )# ----------------------------------------------------------------------------cdef PyLogicInterface PyLogicInterface_factory(U64 _id, LogicInterface *cppLogicInterface):    cdef PyLogicInterface instance = PyLogicInterface.__new__(PyLogicInterface)    instance.thisptr = cppLogicInterface    instance.id = _id    return instance# ----------------------------------------------------------------------------cdef PyLogic16Interface PyLogic16Interface_factory(U64 _id, Logic16Interface *cppLogic16Interface):    cdef PyLogic16Interface instance = PyLogic16Interface.__new__(PyLogic16Interface)    instance.thisptr = cppLogic16Interface    instance.id = _id    return instance# ----------------------------------------------------------------------------cdef void __stdcall OnConnect( U64 device_id, GenericInterface* device_interface, void* user_data ) with gil:    cdef Logic16Interface *logic16    cdef LogicInterface *logic    pylogic_interface = None    try:        logic16 = <Logic16Interface*?>device_interface        pylogic_interface = PyLogic16Interface_factory(device_id, logic16)    except TypeError:        logic = <LogicInterface*?>device_interface        pylogic_interface = PyLogicInterface_factory(device_id, logic)    if pylogic_interface is not None:        (<LogicInterface *> device_interface).RegisterOnReadData(&OnReadData)        (<LogicInterface *> device_interface).RegisterOnError(&OnError)        PyDevicesManager.add_device(pylogic_interface)# ----------------------------------------------------------------------------cdef void __stdcall OnError( U64 device_id, void* user_data ) with gil:    PyDevicesManager.on_error(device_id)# ----------------------------------------------------------------------------cdef void __stdcall OnDisconnect( U64 device_id, void* user_data ) with gil:    PyDevicesManager.on_disconnect(device_id)# ----------------------------------------------------------------------------cdef void __stdcall OnReadData( U64 device_id, U8* data, U32 data_length, void* user_data ) with gil:    cdef PyLogic16Interface device = PyDevicesManager.get_device(device_id)    cdef U16* data16    cdef np.ndarray[np.npy_uint16] n16    cdef np.ndarray[np.npy_uint8] n8    cdef Analyzer analyzer    if device is not None:        analyzer = device.get_analyzer()        if analyzer is not None:            if isinstance(device, PyLogic16Interface):                n16 = np.zeros(data_length / 2, dtype=np.uint16)                data16 = <U16*> data                # memcpy takes number of 'bytes' to copy (which is why it is not data_length/2)                memcpy(n16.data, data16, data_length)                analyzer.add_u16_data_block(n16)                PyDevicesManager.on_read_data16(device_id, n16)            else:                n8 = np.zeros(data_length, dtype=np.uint8)                memcpy(n8.data, data, data_length)                analyzer.add_u8_data_block(n8)                PyDevicesManager.on_read_data8(device_id, n8)    DeleteU8ArrayPtr(data)        # ----------------------------------------------------------------------------PyEval_InitThreads()RegisterOnConnect(&OnConnect)RegisterOnDisconnect(&OnDisconnect)